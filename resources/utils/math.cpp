#include "math.h"
#include "../sdk/interfaces.h"

bool M::Setup()
{
	const void *hVstdLib = MEM::GetModuleBaseHandle(VSTDLIB_DLL);

	if (hVstdLib == nullptr)
		return false;

	RandomSeed = reinterpret_cast<RandomSeedFn>(MEM::GetExportAddress(hVstdLib, XorStr("RandomSeed")));
	if (RandomSeed == nullptr)
		return false;

	RandomFloat = reinterpret_cast<RandomFloatFn>(MEM::GetExportAddress(hVstdLib, XorStr("RandomFloat")));
	if (RandomFloat == nullptr)
		return false;

	RandomFloatExp = reinterpret_cast<RandomFloatExpFn>(MEM::GetExportAddress(hVstdLib, XorStr("RandomFloatExp")));
	if (RandomFloatExp == nullptr)
		return false;

	RandomInt = reinterpret_cast<RandomIntFn>(MEM::GetExportAddress(hVstdLib, XorStr("RandomInt")));
	if (RandomInt == nullptr)
		return false;

	RandomGaussianFloat = reinterpret_cast<RandomGaussianFloatFn>(MEM::GetExportAddress(hVstdLib, XorStr("RandomGaussianFloat")));
	if (RandomGaussianFloat == nullptr)
		return false;

	return true;
}

void M::VectorAngles(const Vector &vecForward, QAngle &angView)
{
	float flPitch, flYaw;

	if (vecForward.x == 0.f && vecForward.y == 0.f)
	{
		flPitch = (vecForward.z > 0.f) ? 270.f : 90.f;
		flYaw = 0.f;
	}
	else
	{
		flPitch = std::atan2f(-vecForward.z, vecForward.Length2D()) * 180.f / M_PI;

		if (flPitch < 0.f)
			flPitch += 360.f;

		flYaw = std::atan2f(vecForward.y, vecForward.x) * 180.f / M_PI;

		if (flYaw < 0.f)
			flYaw += 360.f;
	}

	angView.x = flPitch;
	angView.y = flYaw;
	angView.z = 0.f;
}

void M::AngleVectors(const QAngle &angView, Vector *pForward, Vector *pRight, Vector *pUp)
{
	float sp, sy, sr, cp, cy, cr;

	DirectX::XMScalarSinCos(&sp, &cp, M_DEG2RAD(angView.x));
	DirectX::XMScalarSinCos(&sy, &cy, M_DEG2RAD(angView.y));
	DirectX::XMScalarSinCos(&sr, &cr, M_DEG2RAD(angView.z));

	if (pForward != nullptr)
	{
		pForward->x = cp * cy;
		pForward->y = cp * sy;
		pForward->z = -sp;
	}

	if (pRight != nullptr)
	{
		pRight->x = -1 * sr * sp * cy + -1 * cr * -sy;
		pRight->y = -1 * sr * sp * sy + -1 * cr * cy;
		pRight->z = -1 * sr * cp;
	}

	if (pUp != nullptr)
	{
		pUp->x = cr * sp * cy + -sr * -sy;
		pUp->y = cr * sp * sy + -sr * cy;
		pUp->z = cr * cp;
	}
}

void M::AngleMatrix(const QAngle &angView, matrix3x4_t &matOutput, const Vector &vecOrigin)
{
	float sp, sy, sr, cp, cy, cr;

	DirectX::XMScalarSinCos(&sp, &cp, M_DEG2RAD(angView.x));
	DirectX::XMScalarSinCos(&sy, &cy, M_DEG2RAD(angView.y));
	DirectX::XMScalarSinCos(&sr, &cr, M_DEG2RAD(angView.z));

	matOutput.SetForward(Vector(cp * cy, cp * sy, -sp));

	const float crcy = cr * cy;
	const float crsy = cr * sy;
	const float srcy = sr * cy;
	const float srsy = sr * sy;

	matOutput.SetLeft(Vector(sp * srcy - crsy, sp * srsy + crcy, sr * cp));
	matOutput.SetUp(Vector(sp * crcy + srsy, sp * crsy - srcy, cr * cp));
	matOutput.SetOrigin(vecOrigin);
}

Vector2D M::AnglePixels(const float flSensitivity, const float flPitch, const float flYaw, const QAngle &angBegin, const QAngle &angEnd)
{
	QAngle angDelta = angBegin - angEnd;
	angDelta.Normalize();

	const float flPixelMovePitch = (-angDelta.x) / (flYaw * flSensitivity);
	const float flPixelMoveYaw = (angDelta.y) / (flPitch * flSensitivity);

	return Vector2D(flPixelMoveYaw, flPixelMovePitch);
}

QAngle M::PixelsAngle(const float flSensitivity, const float flPitch, const float flYaw, const Vector2D &vecPixels)
{
	const float flAngleMovePitch = (-vecPixels.x) * (flYaw * flSensitivity);
	const float flAngleMoveYaw = (vecPixels.y) * (flPitch * flSensitivity);

	return QAngle(flAngleMoveYaw, flAngleMovePitch, 0.f);
}

QAngle M::CalcAngle(const Vector &vecStart, const Vector &vecEnd)
{
	QAngle angView;
	const Vector vecDelta = vecEnd - vecStart;
	VectorAngles(vecDelta, angView);
	angView.Normalize();

	return angView;
}

Vector M::VectorTransform(const Vector &vecTransform, const matrix3x4_t &matrix)
{
	return Vector(vecTransform.DotProduct(matrix[0]) + matrix[0][3],
				  vecTransform.DotProduct(matrix[1]) + matrix[1][3],
				  vecTransform.DotProduct(matrix[2]) + matrix[2][3]);
}

Vector M::ExtrapolateTick(const Vector &p0, const Vector &v0)
{

	return p0 + (v0 * I::Globals->flIntervalPerTick);
}

void M::RotatePoint(const ImVec2 &vecIn, const float flAngle, ImVec2 *pOutPoint)
{
	if (&vecIn == pOutPoint)
	{
		const ImVec2 vecPoint = vecIn;
		RotatePoint(vecPoint, flAngle, pOutPoint);
		return;
	}

	const float flSin = std::sinf(M_DEG2RAD(flAngle));
	const float flCos = std::cosf(M_DEG2RAD(flAngle));

	pOutPoint->x = vecIn.x * flCos - vecIn.y * flSin;
	pOutPoint->y = vecIn.x * flSin + vecIn.y * flCos;
}

void M::RotateCenter(const ImVec2 &vecCenter, const float flAngle, ImVec2 *pOutPoint)
{
	const float flSin = std::sinf(M_DEG2RAD(flAngle));
	const float flCos = std::cosf(M_DEG2RAD(flAngle));

	pOutPoint->x -= vecCenter.x;
	pOutPoint->y -= vecCenter.y;

	const float x = pOutPoint->x * flCos - pOutPoint->y * flSin;
	const float y = pOutPoint->x * flSin + pOutPoint->y * flCos;

	pOutPoint->x = x + vecCenter.x;
	pOutPoint->y = y + vecCenter.y;
}

/*--------------------Extra Math Shit--------------------*/

template <typename T, typename... Ts>
T M::RandomIntSet(T first, Ts... rest) {
    std::vector<T> numbers = {first, rest...};
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, numbers.size() - 1);

    return numbers[dis(gen)];
}

int M::RandomIntRange(int min, int max) {
	return rand() % (max - min + 1) + min;
}

int M::IntAddSubtractRange(int addstart, int addend, int subtractstart, int subtractend, int amount) {

}

int M::IntAddRange(int addstart, int addend, int amount) {

}

int M::IntSubtractRange(int subtractstart, int subtractend, int amount) {
	
}